//+------------------------------------------------------------------+
//|                                              YanTE_SMC_Bot.mq5   |
//|                                  Copyright 2024, YanTE Trading   |
//+------------------------------------------------------------------+
#property strict
#include <Trade\Trade.mqh>

//--- INPUT PARAMETERS
input double   InpRiskPercent  = 2.0;       // Fixed Risk Management (%)
input int      InpTP_Ratio     = 3;         // Target Take Profit (1:3 RR)
input int      InpBE_Ratio     = 2;         // Secure at 1:2 RR
input int      InpTrailPoints  = 300;       // Trailing distance (Points)
input int      InpMaxSpread    = 30;        // Max allowed spread (Points)
input int      InpMagicNumber  = 888123;    // EA Magic Number

//--- GLOBAL VARIABLES
CTrade trade;

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick() {
    // 1. Profit Securing & Trailing Logic
    ApplyTrailingStop();

    // 2. Placeholder for your SMC Entry Logic
    // If(SMC_Entry_Condition && IsMarketSafe()) {
    //    ExecuteTrade(ORDER_TYPE_BUY, sl_price, tp_price);
    // }
}

//+------------------------------------------------------------------+
//| FIXED RISK LOT CALCULATION (2%)                                  |
//+------------------------------------------------------------------+
double CalculateLotSize(double sl_distance_points) {
    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double risk_amount = balance * (InpRiskPercent / 100.0);
    
    double tick_value = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
    double tick_size  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
    
    if(sl_distance_points <= 0 || tick_value <= 0) return 0;

    // Formula: Risk / (Points * (TickValue / TickSize))
    double lot = risk_amount / (sl_distance_points * (tick_value / tick_size));
    
    // Normalize to broker limits
    double step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    lot = MathFloor(lot / step) * step;
    
    return MathMin(MathMax(lot, SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN)), SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX));
}

//+------------------------------------------------------------------+
//| EXECUTION & KILL SWITCH                                          |
//+------------------------------------------------------------------+
void ExecuteTrade(ENUM_ORDER_TYPE type, double sl, double tp) {
    if(!IsMarketSafe()) return;

    double entry = (type == ORDER_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double sl_dist = MathAbs(entry - sl) / _Point;
    double lots = CalculateLotSize(sl_dist);

    if(lots <= 0) return;

    trade.SetExpertMagicNumber(InpMagicNumber);
    
    if(type == ORDER_TYPE_BUY) trade.Buy(lots, _Symbol, entry, sl, tp);
    else trade.Sell(lots, _Symbol, entry, sl, tp);

    // KILL SWITCH VALIDATION
    ulong ticket = trade.ResultDeal();
    if(PositionSelectByTicket(ticket)) {
        if(PositionGetDouble(POSITION_SL) <= 0) {
            Print("CRITICAL: SL missing! Closing position immediately.");
            trade.PositionClose(ticket);
        }
    }
}

//+------------------------------------------------------------------+
//| TRAILING STOP & 1:2 RR BREAK-EVEN                                |
//+------------------------------------------------------------------+
void ApplyTrailingStop() {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket) && PositionGetInteger(POSITION_MAGIC) == InpMagicNumber) {
            
            double open = PositionGetDouble(POSITION_PRICE_OPEN);
            double cur  = PositionGetDouble(POSITION_PRICE_CURRENT);
            double sl   = PositionGetDouble(POSITION_SL);
            double tp   = PositionGetDouble(POSITION_TP);
            double risk = MathAbs(open - sl);

            if(risk <= 0) continue;

            if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) {
                // Check if 1:2 RR reached
                if(cur >= open + (risk * InpBE_Ratio)) {
                    double trail_sl = cur - (InpTrailPoints * _Point);
                    // Move to BE first, then trail
                    double new_sl = MathMax(open, trail_sl); 
                    if(new_sl > sl + (10 * _Point)) trade.PositionModify(ticket, new_sl, tp);
                }
            } 
            else if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL) {
                if(cur <= open - (risk * InpBE_Ratio)) {
                    double trail_sl = cur + (InpTrailPoints * _Point);
                    double new_sl = (sl == 0) ? open : MathMin(open, trail_sl);
                    if(new_sl < sl - (10 * _Point) || sl == 0) trade.PositionModify(ticket, new_sl, tp);
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| BROKER SAFETY FILTERS                                            |
//+------------------------------------------------------------------+
bool IsMarketSafe() {
    long spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
    if(spread > InpMaxSpread) {
        Print("Trade Blocked: Spread (", spread, ") exceeds Max (", InpMaxSpread, ")");
        return false;
    }
    
    if(!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED) || !MQLInfoInteger(MQL_TRADE_ALLOWED)) return false;
    
    return true;
}
